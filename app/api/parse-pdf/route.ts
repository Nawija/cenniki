import { NextRequest, NextResponse } from "next/server";
import Groq from "groq-sdk";
import fs from "fs/promises";
import path from "path";
import { producenciConfig } from "@/producenci";

const groq = new Groq({
    apiKey: process.env.GROQ_API_KEY,
});

// Typy dla pdf2json
type PDFTextR = {
    T: string;
};

type PDFTextItem = {
    R?: PDFTextR[];
};

type PDFPage = {
    Texts?: PDFTextItem[];
};

type PDFData = {
    Pages?: PDFPage[];
};

type PDFErrorData = {
    parserError?: Error;
};

// Funkcja do ekstrakcji tekstu z PDF u≈ºywajƒÖc pdf2json
async function extractTextFromPDF(buffer: Buffer): Promise<string> {
    const PDFParser = (await import("pdf2json")).default;

    return new Promise((resolve, reject) => {
        const pdfParser = new PDFParser();

        pdfParser.on("pdfParser_dataError", (errData: PDFErrorData) =>
            reject(errData.parserError)
        );

        pdfParser.on("pdfParser_dataReady", (pdfData: PDFData) => {
            try {
                let text = "";
                if (pdfData.Pages) {
                    pdfData.Pages.forEach((page) => {
                        if (page.Texts) {
                            page.Texts.forEach((textItem) => {
                                if (textItem.R) {
                                    textItem.R.forEach((r) => {
                                        if (r.T) {
                                            text +=
                                                decodeURIComponent(r.T) + " ";
                                        }
                                    });
                                }
                            });
                            text += "\n";
                        }
                    });
                }
                resolve(text);
            } catch (error) {
                reject(error);
            }
        });

        pdfParser.parseBuffer(buffer);
    });
}

export async function POST(request: NextRequest) {
    try {
        const formData = await request.formData();
        const file = formData.get("pdf") as File;
        const manufacturer = formData.get("manufacturer") as string;

        if (!file) {
            return NextResponse.json(
                { error: "Brak pliku PDF" },
                { status: 400 }
            );
        }

        // Konwersja pliku do bufora
        const bytes = await file.arrayBuffer();
        const buffer = Buffer.from(bytes);

        // Ekstrakcja tekstu z PDF
        let pdfText = await extractTextFromPDF(buffer);

        // Ograniczenie rozmiaru tekstu (Groq ma limit ~32k token√≥w)
        const MAX_CHARS = 15000;

        if (pdfText.length > MAX_CHARS) {
            console.log(
                `PDF zbyt d≈Çugi (${pdfText.length} znak√≥w), skracam do ${MAX_CHARS}`
            );
            // Bierzemy poczƒÖtek (nag≈Ç√≥wki) i ≈õrodek (produkty)
            const headerChars = Math.floor(MAX_CHARS * 0.2);
            const contentChars = MAX_CHARS - headerChars;
            pdfText =
                pdfText.substring(0, headerChars) +
                "\n...[czƒô≈õƒá tekstu pominiƒôta]...\n" +
                pdfText.substring(pdfText.length - contentChars);
        }

        // Przygotowanie promptu dla AI
        // Sprawd≈∫ czy producent ma custom prompt
        // Normalizuj nazwƒô - spacje na my≈õlniki, lowercase
        const manufacturerNormalized = manufacturer
            ?.toLowerCase()
            .trim()
            .replace(/\s+/g, "-");

        console.log("üîç DEBUG: manufacturer =", manufacturer);
        console.log(
            "üîç DEBUG: manufacturerNormalized =",
            manufacturerNormalized
        );

        const producentConfig = producenciConfig.find(
            (p) => p.name === manufacturerNormalized
        );

        console.log(
            "üîç DEBUG: producentConfig =",
            producentConfig?.displayName || "NIE ZNALEZIONO"
        );
        console.log(
            "üîç DEBUG: displayType =",
            producentConfig?.displayType || "brak"
        );
        console.log(
            "üîç DEBUG: ma custom prompt =",
            !!producentConfig?.aiPrompt
        );

        // Wczytaj istniejƒÖcy JSON producenta do kontekstu por√≥wnania (skr√≥t do promptu)
        let existingDataForPrompt: any = null;
        let existingDataSnippet = "";
        try {
            if (manufacturerNormalized) {
                const dataDir = path.join(process.cwd(), "data");
                const fileName =
                    manufacturer.charAt(0).toUpperCase() +
                    manufacturer.slice(1).toLowerCase();
                const filePath = path.join(dataDir, `${fileName}.json`);
                const existingContent = await fs.readFile(filePath, "utf-8");
                existingDataForPrompt = JSON.parse(existingContent);
                const asString = JSON.stringify(existingDataForPrompt);
                existingDataSnippet =
                    asString.length > 12000
                        ? asString.slice(0, 6000) +
                          "\n...[TRIM]...\n" +
                          asString.slice(-6000)
                        : asString;
            }
        } catch {
            // brak istniejƒÖcego pliku jest ok
        }

        const defaultSystemPrompt = `Jeste≈õ ekspertem w analizie cennik√≥w mebli. Twoim zadaniem jest wyekstrahowanie danych z cennika i zwr√≥cenie ich w formacie JSON.

Struktura wyj≈õciowa zale≈ºy od typu produktu:

DLA KRZESE≈Å, SIDEBOARD√ìW i podobnych (z grupami cenowymi):
{
  "title": "CENNIK [NAZWA MIESIƒÑCA] [ROK]",
  "categories": {
    "krzes≈Ça": {
      "NAZWA_PRODUKTU": {
        "image": "/images/${manufacturer || "producent"}/nazwa.webp",
        "material": "materia≈Ç (np. BUK / DƒÑB)",
        "prices": {
          "Grupa I": cena,
          "Grupa II": cena,
          "Grupa III": cena,
          "Grupa IV": cena
        },
        "options": [
          "opcja 1",
          "opcja 2"
        ],
        "previousName": "poprzednia nazwa je≈õli jest"
      }
    }
  }
}

DLA STO≈Å√ìW (z r√≥≈ºnymi wymiarami i cenami):
{
  "title": "CENNIK [NAZWA MIESIƒÑCA] [ROK]",
  "categories": {
    "sto≈Çy": {
      "NAZWA_PRODUKTU": {
        "image": "/images/${manufacturer || "producent"}/nazwa.webp",
        "material": "materia≈Ç (np. BUK / DƒÑB)",
        "previousName": "poprzednia nazwa je≈õli jest",
        "sizes": [
          {
            "dimension": "wymiar sto≈Çu (np. √ò110x310, 120x80)",
            "prices": "cena jako string lub liczba"
          },
          {
            "dimension": "√ò130x330",
            "prices": "6900"
          }
        ],
        "description": [
          "informacja 1 (np. ≈ÇƒÖczenie kolor√≥w - blat/noga)",
          "informacja 2 (np. wk≈Çad oddzielnie 4x50)",
          "dodatkowe opcje i uwagi"
        ]
      }
    }
  }
}

WA≈ªNE ZASADY:
- TYTU≈Å: WyciƒÖgnij tytu≈Ç cennika z datƒÖ w formacie "CENNIK [MIESIƒÑC] [ROK]" (np. "CENNIK STYCZE≈É 2025")
- Nazwy produkt√≥w WIELKIMI LITERAMI
- Kategorie ma≈Çymi literami (krzes≈Ça, sto≈Çy, naro≈ºniki, sofy, fotele, pufy, poduszki, itp.)

DLA KRZESE≈Å/FOTELI/SIDEBOARD√ìW:
- U≈ºywaj pola "prices" jako obiekt z grupami cenowymi (Grupa I, Grupa II, itd.)
- Ceny jako liczby (bez z≈Ç, PLN itp.)
- Opcje, notatki i informacje dodatkowe w tablicy "options"

DLA STO≈Å√ìW:
- U≈ºywaj pola "sizes" jako tablica obiekt√≥w z wymiarem i cenƒÖ
- Pole "dimension" zawiera wymiar sto≈Çu (np. "√ò110x310", "120x80x75")
- Pole "prices" w ka≈ºdym rozmiarze to string lub liczba (cena dla tego rozmiaru)
- Zamiast "options" u≈ºywaj pola "description" - tablica string√≥w z dodatkowymi informacjami
- W "description" umieszczaj: informacje o wk≈Çadach, prowadnicach, opcjach kolor√≥w, wyko≈Ñczeniach

OG√ìLNE:
- Je≈õli nie ma grup cenowych, u≈ºyj prostego formatu: "price": warto≈õƒá
- Je≈õli PDF zawiera zdjƒôcia produkt√≥w, spr√≥buj dopasowaƒá nazwy obraz√≥w
- Zwr√≥ƒá uwagƒô na podwy≈ºki cen, promocje, nowo≈õci
- Zachowaj wszystkie informacje o kolorach, materia≈Çach, wyko≈Ñczeniach
- Je≈õli produkt ma poprzedniƒÖ nazwƒô, dodaj pole "previousName"
ODPOWIED≈π MUSI BYƒÜ POPRAWNYM JSON!`;

    // Ustaw tryb DIFF: AI ma zwr√≥ciƒá tylko zmiany wzglƒôdem istniejƒÖcego JSON
    const diffModePrompt = `\n\nTRYB DIFF (WA≈ªNE):\n- Por√≥wnaj PDF z przekazanym EXISTING_JSON tego producenta.\n- ZWR√ìƒÜ TYLKO ZMIENIONE FRAGMENTY w formacie:\n{\n  \"title\"?: \"nowy tytu≈Ç je≈õli zmieniony\",\n  \"categories\": {\n    \"kategoria\": { \"PRODUKT\": { tylko pola cenowe: prices | sizes | elements } }\n  }\n}\n- Je≈õli brak zmian, zwr√≥ƒá: { \"categories\": {} }.\n- NIE dodawaj image/material/options/description (chyba ≈ºe sƒÖ kluczowe dla producenta).\n- Dla MP Nidzica ZAWSZE u≈ºywaj pola elements -> grupy -> litery A/B/C/D.\n- Dla nowych produkt√≥w zwr√≥ƒá minimalny, producent-specyficzny zestaw danych (np. elements dla MP Nidzica, prices/sizes dla Bomar).`;

    const systemPrompt = `${producentConfig?.aiPrompt || defaultSystemPrompt}${diffModePrompt}`;

        if (producentConfig?.aiPrompt) {
            console.log(
                "‚úÖ U≈ºywam CUSTOM promptu dla:",
                producentConfig.displayName
            );
        } else {
            console.log(
                "‚ö†Ô∏è U≈ºywam DOMY≈öLNEGO promptu (brak custom dla:",
                manufacturer,
                ")"
            );
        }

        const userPrompt = `MATERIA≈Å WEJ≈öCIOWY\n[PDF_TEXT]\n${pdfText}\n\n[EXISTING_JSON]\n${existingDataSnippet || "<brak>"}\n\nZADANIE: Zastosuj TRYB DIFF i zwr√≥ƒá tylko zmiany wzglƒôdem EXISTING_JSON.`;

        // U≈ºycie Groq AI (darmowe, 6000 req/dzie≈Ñ)
        const completion = await groq.chat.completions.create({
            model: "llama-3.3-70b-versatile",
            messages: [
                { role: "system", content: systemPrompt },
                { role: "user", content: userPrompt },
            ],
            temperature: 0.1,
            response_format: { type: "json_object" },
        });

        const result = completion.choices[0].message.content;
        const newData = JSON.parse(result || "{}");

        // Inicjalizacja logu zmian
        const changeLog = {
            newCategories: [] as string[],
            newProducts: [] as Array<{
                category: string;
                name: string;
                oldData: null;
                newData: Record<string, unknown>;
            }>,
            updatedPrices: [] as Array<{
                category: string;
                name: string;
                changes: string;
                oldData: Record<string, unknown>;
                newData: Record<string, unknown>;
            }>,
        };

        // Automatyczny zapis do folderu data z merge (nak≈Çadanie DIFF na istniejƒÖce dane)
        let mergedData: any = newData;
        if (manufacturer) {
            try {
                const dataDir = path.join(process.cwd(), "data");

                // Kapitalizacja pierwszej litery dla nazwy pliku
                const fileName =
                    manufacturer.charAt(0).toUpperCase() +
                    manufacturer.slice(1).toLowerCase();
                const filePath = path.join(dataDir, `${fileName}.json`);

                // Sprawd≈∫ czy plik ju≈º istnieje
                let existingData = null;
                try {
                    const existingContent = await fs.readFile(
                        filePath,
                        "utf-8"
                    );
                    existingData = JSON.parse(existingContent);
                    console.log(
                        `üìÑ Znaleziono istniejƒÖcy plik: data/${fileName}.json`
                    );
                } catch {
                    console.log(
                        `üÜï Tworzenie nowego pliku: data/${fileName}.json`
                    );
                }

                // Merge danych

                if ((existingData && existingData.categories) || newData.categories) {
                    mergedData = {
                        title: newData.title || existingData?.title,
                        categories: { ...(existingData?.categories || {}) },
                    };

                    // Iteruj po kategoriach z nowego cennika
                    Object.entries(newData.categories || {}).forEach(
                        ([categoryName, newProducts]) => {
                            if (!mergedData.categories[categoryName]) {
                                // Nowa kategoria - dodaj ca≈ÇƒÖ
                                mergedData.categories[categoryName] =
                                    newProducts as Record<string, unknown>;
                                changeLog.newCategories.push(categoryName);
                                console.log(
                                    `+ Dodano nowƒÖ kategoriƒô: ${categoryName}`
                                );
                            } else {
                                // Kategoria istnieje - merge produkt√≥w
                                const productsObj = newProducts as Record<
                                    string,
                                    Record<string, unknown>
                                >;
                                Object.entries(productsObj).forEach(
                                    ([productName, newProductData]) => {
                                        const existingProduct =
                                            mergedData.categories[categoryName][
                                                productName
                                            ];

                                        if (!existingProduct) {
                                            // Nowy produkt - dodaj ca≈Ço≈õƒá
                                            mergedData.categories[categoryName][
                                                productName
                                            ] = newProductData;
                                            changeLog.newProducts.push({
                                                category: categoryName,
                                                name: productName,
                                                oldData: null,
                                                newData:
                                                    newProductData as Record<
                                                        string,
                                                        unknown
                                                    >,
                                            });
                                            console.log(
                                                `‚ûï Dodano nowy produkt: ${categoryName}/${productName}`
                                            );
                                        } else {
                                            // Produkt istnieje - aktualizuj TYLKO to, co przysz≈Ço w DIFF
                                            const existingProductObj =
                                                existingProduct as Record<string, unknown>;

                                            const updated: Record<string, any> = {
                                                ...existingProductObj, // zachowaj resztƒô
                                            };
                                            if ((newProductData as any).prices !== undefined) {
                                                updated.prices = (newProductData as any).prices;
                                            }
                                            if ((newProductData as any).sizes !== undefined) {
                                                updated.sizes = (newProductData as any).sizes;
                                            }
                                            if ((newProductData as any).elements !== undefined) {
                                                updated.elements = (newProductData as any).elements;
                                            }
                                            if ((newProductData as any).material !== undefined) {
                                                updated.material = (newProductData as any).material;
                                            }
                                            if ((newProductData as any).previousName !== undefined) {
                                                updated.previousName = (newProductData as any).previousName;
                                            }

                                            mergedData.categories[categoryName][productName] = updated;

                                            // Sprawd≈∫ zmiany cen
                                            const priceChanges: string[] = [];
                                            if (
                                                (newProductData as any).prices &&
                                                JSON.stringify((newProductData as any).prices) !==
                                                    JSON.stringify((existingProductObj as any).prices)
                                            ) {
                                                priceChanges.push(
                                                    "Ceny produktu"
                                                );
                                                console.log(
                                                    `üí∞ Zaktualizowano ceny: ${categoryName}/${productName}`
                                                );
                                            }
                                            if (
                                                (newProductData as any).sizes &&
                                                JSON.stringify((newProductData as any).sizes) !==
                                                    JSON.stringify((existingProductObj as any).sizes)
                                            ) {
                                                priceChanges.push(
                                                    "Rozmiary i ceny"
                                                );
                                                console.log(
                                                    `üí∞ Zaktualizowano rozmiary i ceny: ${categoryName}/${productName}`
                                                );
                                            }
                                            if (
                                                (newProductData as any).elements &&
                                                JSON.stringify((newProductData as any).elements) !==
                                                    JSON.stringify((existingProductObj as any).elements)
                                            ) {
                                                priceChanges.push("Elementy i ceny (MP Nidzica)");
                                                console.log(
                                                    `üí∞ Zaktualizowano elementy/ceny: ${categoryName}/${productName}`
                                                );
                                            }

                                            if (priceChanges.length > 0) {
                                                changeLog.updatedPrices.push({
                                                    category: categoryName,
                                                    name: productName,
                                                    changes:
                                                        priceChanges.join(", "),
                                                    oldData:
                                                        existingProductObj as Record<
                                                            string,
                                                            unknown
                                                        >,
                                                    newData:
                                                        (newProductData as any) as Record<
                                                            string,
                                                            unknown
                                                        >,
                                                });
                                            }
                                        }
                                    }
                                );
                            }
                        }
                    );
                }

                // NIE zapisujemy automatycznie - czekamy na akceptacjƒô u≈ºytkownika
                console.log(
                    `‚è∏Ô∏è  Przygotowano zmiany dla: data/${fileName}.json (oczekuje na akceptacjƒô)`
                );
            } catch (error) {
                console.error("‚ùå B≈ÇƒÖd przygotowania zmian:", error);
            }
        }

        return NextResponse.json({
            success: true,
            data: mergedData,
            rawText: pdfText.substring(0, 500),
            saved: false, // Zawsze false - czekamy na akceptacjƒô
            filePath: manufacturer
                ? `data/${
                      manufacturer.charAt(0).toUpperCase() +
                      manufacturer.slice(1).toLowerCase()
                  }.json`
                : null,
            changeLog,
            pendingApproval: true, // Nowa flaga
        });
    } catch (error) {
        console.error("B≈ÇƒÖd przetwarzania PDF:", error);
        return NextResponse.json(
            {
                error: "B≈ÇƒÖd przetwarzania PDF",
                details:
                    error instanceof Error ? error.message : "Unknown error",
            },
            { status: 500 }
        );
    }
}
